<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Iptables matches</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Iptables Tutorial 1.2.2"
HREF="book1.htm"><LINK
REL="PREVIOUS"
TITLE="What's next?"
HREF="x5568.htm"><LINK
REL="NEXT"
TITLE="Implicit matches"
HREF="x5796.htm"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="table.css"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Iptables Tutorial 1.2.2</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x5568.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x5796.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="MATCHES"
></A
>Chapter 10. Iptables matches</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="c5572.htm#GENERICMATCHES"
>Generic matches</A
></DT
><DT
><A
HREF="x5796.htm"
>Implicit matches</A
></DT
><DT
><A
HREF="x6330.htm"
>Explicit matches</A
></DT
><DT
><A
HREF="x8812.htm"
>What's next?</A
></DT
></DL
></DIV
><P
>In this chapter we'll talk a bit more about matches. I've chosen to
narrow down the matches into five different subcategories. First of all we
have the <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>generic matches</I
></SPAN
>, which can be used in all rules.
Then we have the <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>TCP matches</I
></SPAN
> which can only be applied to
TCP packets. We have <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>UDP matches</I
></SPAN
>
which can only be applied to UDP packets, and
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ICMP matches</I
></SPAN
> which can only be used on
ICMP packets. Finally we have special matches, such
as the state, owner and limit matches and so on. These final matches have in
turn been narrowed down to even more subcategories, even though they  might
not necessarily be different matches at all. I hope this is a reasonable
breakdown and that all people out there can understand it.
   </P
><P
>As you may already understand if you have read the previous chapters, a 
match is something that specifies a special condition within the packet that 
must be true (or false). A single rule can contain several matches of any
kind. For example, we may want to match packets that come from a specific 
host on a our local area network, and on top of that only from specific ports 
on that host. We could then use matches to tell the rule to only apply the 
target - or jump specification - on packets that have a specific source 
address, that come in on the interface that connects to the LAN and the 
packets must be one of the specified ports. If any one of these matches fails 
(e.g., the source address isn't correct, but everything else is true), the 
whole rule fails and the next rule is tested on the packet. If all matches are 
true, however, the target specified by the rule is applied.
   </P
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="GENERICMATCHES"
>Generic matches</A
></H1
><P
>This section will deal with <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Generic matches</I
></SPAN
>. A
generic match is a kind of match that is always available, whatever kind of
protocol we are working on, or whatever match extensions we have loaded. No
special parameters at all are needed to use these matches; in other words. I
have also included the --protocol match here, even though
it is more specific to protocol matches. For example, if we want to use a
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>TCP match</I
></SPAN
>, we need to use the
--protocol match and send TCP as
an option to the match. However, --protocol is also a match
in itself, since it can be used to match specific protocols. The following
matches are always available.
   </P
><DIV
CLASS="TABLE"
><A
NAME="TABLE.GENERICMATCHES"
></A
><P
><B
>Table 10-1. Generic matches</B
></P
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
CLASS="CALSTABLE"
><COL
WIDTH="77"><COL
WIDTH="1*"><TBODY
><TR
><TD
>Match</TD
><TD
>-p, --protocol</TD
></TR
><TR
><TD
>Kernel</TD
><TD
>2.3, 2.4, 2.5 and 2.6</TD
></TR
><TR
><TD
>Example</TD
><TD
>iptables -A INPUT -p tcp</TD
></TR
><TR
><TD
>Explanation</TD
><TD
>This match is used to check for certain protocols.
Examples of protocols are TCP,
UDP and ICMP. The 
protocol must either be one of the internally specified TCP, UDP or ICMP. It 
may also take a value specified in the <A
HREF="a13413.htm#PROTOCOLSTXT"
><I
><I
>/etc/protocols</I
></I
></A
> file, and if it can't find the protocol 
there it will reply with an error. The protocl may also be an integer value. 
For example, the ICMP protocol is integer value 1, TCP is 6 and UDP is 17. 
Finally, it may also take the value ALL. <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ALL</I
></SPAN
> means that 
it matches only TCP, UDP and ICMP. 
If this
match is given the integer value of zero (0), it means ALL protocols, which in
turn is the default behavior, if the --protocol match is
not used. This match can also be inversed with the ! sign,
so --protocol ! tcp would mean to match 
UDP and ICMP. </TD
></TR
><TR
><TD
>Match</TD
><TD
>-s, --src,
--source</TD
></TR
><TR
><TD
>Kernel</TD
><TD
>2.3, 2.4, 2.5 and 2.6</TD
></TR
><TR
><TD
>Example</TD
><TD
>iptables -A INPUT -s 192.168.1.1</TD
></TR
><TR
><TD
>Explanation</TD
><TD
>This is the source match, which is used to match packets,
based on their source IP address. The main form can be used to match single IP
addresses, such as <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>192.168.1.1</I
></SPAN
>. It could also be used
with a netmask in a CIDR "bit" form, by specifying the number of ones (1's) on
the left side of the network mask. This means that we could for example add
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>/24</I
></SPAN
> to use a <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>255.255.255.0</I
></SPAN
> netmask.
We could then match whole IP ranges, such as our local networks or network
segments behind the firewall. The line would then look something like
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>192.168.0.0/24</I
></SPAN
>. This would match all packets in the
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>192.168.0.x</I
></SPAN
> range. Another way is to do it with a
regular netmask in the <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>255.255.255.255</I
></SPAN
> form (i.e.,
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>192.168.0.0/255.255.255.0</I
></SPAN
>). We could also invert the
match with an ! just as before. If we were, in other words,
to use a match in the form of --source ! 192.168.0.0/24, we
would match all packets with a source address not coming from within the
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>192.168.0.x</I
></SPAN
> range. The default is to match all IP
addresses.</TD
></TR
><TR
><TD
>Match</TD
><TD
>-d, --dst,
--destination</TD
></TR
><TR
><TD
>Kernel</TD
><TD
>2.3, 2.4, 2.5 and 2.6</TD
></TR
><TR
><TD
>Example</TD
><TD
>iptables -A INPUT -d 192.168.1.1</TD
></TR
><TR
><TD
>Explanation</TD
><TD
>The --destination match is used for packets
based on their destination address or addresses. It works pretty much the same
as the --source match and has the same syntax, except that
the match is based on where the packets are going to. To match an IP range, we
can add a netmask either in the exact netmask form, or in the number of ones
(1's) counted from the left side of the netmask bits. Examples are:
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>192.168.0.0/255.255.255.0</I
></SPAN
> and
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>192.168.0.0/24</I
></SPAN
>. Both of these are equivalent. We could
also invert the whole match with an ! sign, just as before.
--destination ! 192.168.0.1 would in other words match all
packets except those destined to the <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>192.168.0.1</I
></SPAN
> IP
address.</TD
></TR
><TR
><TD
>Match</TD
><TD
>-i, 
--in-interface</TD
></TR
><TR
><TD
>Kernel</TD
><TD
>2.3, 2.4, 2.5 and 2.6</TD
></TR
><TR
><TD
>Example</TD
><TD
>iptables -A INPUT -i eth0</TD
></TR
><TR
><TD
>Explanation</TD
><TD
>This match is used for the interface the packet came in on.
Note that this option is only legal in the INPUT,
FORWARD and PREROUTING
chains and will return an error message when used anywhere else. The default
behavior of this match, if no particular interface is specified, is to assume
a string value of +. The + value is used
to match a string of letters and numbers. A single + would,
in other words, tell the kernel to match all packets without considering which
interface it came in on. The + string can also be appended
to the type of interface, so eth+ would be all Ethernet
devices. We can also invert the meaning of this option with the help of the
! sign. The line would then have a syntax looking something
like -i ! eth0, which would match all incoming interfaces,
except eth0.</TD
></TR
><TR
><TD
>Match</TD
><TD
>-o, 
--out-interface</TD
></TR
><TR
><TD
>Kernel</TD
><TD
>2.3, 2.4, 2.5 and 2.6</TD
></TR
><TR
><TD
>Example</TD
><TD
>iptables -A FORWARD -o eth0</TD
></TR
><TR
><TD
>Explanation</TD
><TD
>The --out-interface match is used for
packets on the interface from which they are leaving. Note that this match is
only available in the OUTPUT,
FORWARD and POSTROUTING
chains, the opposite in fact of the --in-interface match.
Other than this, it works pretty much the same as the
--in-interface match. The + extension is
understood as matching all devices of similar type, so eth+
would match all eth devices and so on. To invert the
meaning of the match, you can use the ! sign in exactly the
same way as for the --in-interface match. If no
--out-interface is specified, the default behavior for this
match is to match all devices, regardless of where the packet is 
going.</TD
></TR
><TR
><TD
>Match</TD
><TD
>-f, --fragment</TD
></TR
><TR
><TD
>Kernel</TD
><TD
>2.3, 2.4, 2.5 and 2.6</TD
></TR
><TR
><TD
>Example</TD
><TD
>iptables -A INPUT -f</TD
></TR
><TR
><TD
>Explanation</TD
><TD
>This match is used to match the second and third part of a
fragmented packet. The reason for this is that in the case of fragmented
packets, there is no way to tell the source or destination ports of the
fragments, nor ICMP types, among other things. Also,
fragmented packets might in rather special cases be used to compound attacks
against other computers. Packet fragments like this will not be matched by
other rules, and hence this match was created. This option can also be used in
conjunction with the ! sign; however, in this case the
! sign must precede the match, i.e. !
-f. When this match is inverted, we match all header fragments
and/or unfragmented packets. What this means, is that we match all the first
fragments of fragmented packets, and not the second, third, and so on. We also
match all packets that have not been fragmented during transfer. Note also
that there are really good defragmentation options within the kernel that you
can use instead. As a secondary note, if you use connection tracking you will
not see any fragmented packets, since they are dealt with before hitting any
chain or table in iptables.</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x5568.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.htm"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x5796.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>What's next?</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Implicit matches</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>